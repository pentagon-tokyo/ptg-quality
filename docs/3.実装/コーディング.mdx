# コーディングルール

開発のフローの中で最も重要な工程であるコーディングについて気をつけるべきことについて解説します。

## コードを書く際に意識すべきこと

### 責務を意識する

**重要なのは「関心の分離」です。**

> 関心の分離とは、ソフトウェア工学においては、プログラムを関心（責任・何をしたいのか）毎に分離された構成要素で構築することである。

引用：[wikipedia](https://ja.wikipedia.org/wiki/%E9%96%A2%E5%BF%83%E3%81%AE%E5%88%86%E9%9B%A2#:~:text=%E9%96%A2%E5%BF%83%E3%81%AE%E5%88%86%E9%9B%A2%EF%BC%88%E3%81%8B%E3%82%93%E3%81%97%E3%82%93,%E6%89%8B%E5%8A%A9%E3%81%91%E3%81%99%E3%82%8B%E3%82%82%E3%81%AE%E3%82%82%E3%81%82%E3%82%8B%E3%80%82)

優秀なエンジニアは、そのクラスが何をすべきで何をすべきではないのかを意識してコードを書いています。責務を意識しないで書いたコードは、分かりづらくメンテナンスしにくコードとなるでしょう。プルリクエスト時に指摘を受け、大きな出戻りが発生します。

<Success>クラスやファイルの責務を考えてコードを書こう！</Success>

### 通信部分を実装する時

フロントエンドエンジニアが、サーバーからデータ取得するような通信部分の実装する際に、注意すべきことは、正常系と異常系の２つを考慮して実装することです。

正常系とは、期待するデータを受け取り、期待する結果が返ってくることを想定した場合のことです。一方、通常ユーザーが入力しないであろうデータを送ったり、サーバー側でエラーが発生し、期待する結果が返ってこない場合を想定することを異常系と呼びます。

#### 良いコード

```dart
class UserRepository {
  final ApiService apiService;

  UserRepository(this.apiService);

  Future<void> getUsers() async {
    try {
      List<User> users = await apiService.fetchUsers();

      if (users.isEmpty) {
        print('ユーザー情報はありません。');
      } else {
        print('ユーザー情報を取得しました:');
        for (var user in users) {
          print('ID: ${user.id}, 名前: ${user.name}, 年齢: ${user.age}');
        }
      }
    } catch (e) {
      print('エラーが発生しました: ${e.toString()}');
    }
  }
}

```

#### 悪いコード

```dart
class UserRepository {
  final ApiService apiService;

  UserRepository(this.apiService);

  Future<void> getUsers() async {
    List<User> users = await apiService.fetchUsers();
    print('ユーザー情報を取得しました:');
    for (var user in users) {
      print('ID: ${user.id}, 名前: ${user.name}, 年齢: ${user.age}');
    }
  }
}
```

<Info>
  ジュニアエンジニアの場合、異常系を考慮せず実装してしまうため、バグが混入することがあります。ユーザーやサーバーが正常でない場合を考えて、実装をする必要があります。
</Info>

### UI を実装する時

フロントエンドエンジニアが UI を実装する場合、デザインの再現度を意識しましょう。ただし、限られた予算の中で制作をしているため、完璧を追い求めないことが重要だと考えています。

デザイナーは次のことを意識してデザインを制作しています。

- 整列するように余白を意識している。
- 情報の塊がわかるようにあえて余白をあけている
- テキストやボタンの色
- 文字サイズや要素の大きさ

ある程度、開発が完了した際に、デザイナーにレビューをしてもらいましょう。
デザイナーがこだわっている箇所についてフィードバックを貰えるはずです。

<Info>
  当社では、プルリクエストのレビュー時にデザイナーを交えることで、デザインチェックを走らせるとともに、デザイナーとエンジニアの認識の違いを早期発見できる体制をとっています。
</Info>

### ビジネスロジックを実装する時

ビジネスロジックとは、アプリ固有のロジックのことです。
先程、「関心の分離」という話をしましたが、例えば、UI 層にビジネスロジックを書くのはよくありません。なぜなら、UI はあくまでも UI を制作、制御するのが責務だからです。

ビジネスロジックは、サービス層を作成し、UI から分離させます。また、単体テストが書ける状態で実装を行います。

## コメントに関するルール

コメントを書くべきかどうかという議論がありますが、コメントを書くことのメリット、デメリットを把握した上で、コメントを書くべきところには、コメントを書きましょう。

例えば、複雑な処理をするメソッドやビジネスロジックを実装する部分では、コメントを書いた方が、他の人が読みやすいでしょう。

一方で、ソースコードを変更したけど、コメントを変更しなかったより、逆に分かりづらくなることがあります。コメントはしっかりと運用してく必要があるので、プルリクエスト時やレビュー時に、実装とコメントの内容が合っているか確認する必要があります。

以下に、良いコメントと悪いコメントの例を記載します。

### 良いコメントの書き方

明確性: コメントはコードの目的を明確に伝えるべきです。
複雑な処理をしている際に、ステップ毎にコメントを記入するのが効果的です。

```dart
// お問い合わせがあったユーザーの情報を取得
Future<User> fetchUser(int contactUserId) async {
  // ...
}
```

なぜコメント: コードが何をするかではなく、なぜそのようにするのかを説明する

```dart
// カスタムソーターを使用しています。なぜなら、Dartの組み込みソート関数はこのケースでは適切な結果を返さないからです。
list.sort(customSorter);
```

### 悪いコメントの書き方

冗長: コードが自己説明的である場合、それを再度説明するコメントは冗長で不要です。

```dart
// このコードはユーザーIDに1を加算します。
int newUserId = oldUserId + 1;
```

あいまいな表現や専門用語の過度な使用は避けるべきです。
また、具体的な内容を示さずに「このコードを修正する」といったコメントも有用ではありません。

```dart
// FIXME: この部分はもっと良くなるべき。
void someFunction() {
  // ...
}
```

コメントの無視: コードの変更が行われたときにコメントが更新されない場合、それは混乱を招く可能性があります。

```dart
// この関数はユーザーの電話番号を取得します。（実際にはメールアドレスを取得している）
String fetchUserContact(int userId) {
  // ...
}
```

### TODO コメントと FIXME コメント

実装をしている最中にバグや残タスクに気がついたら、TODO や FIXME コメントを記述します。
この際、具体的にコメントを書くことに注意しましょう。

プロジェクトのリーダーは、プルリクエスト時に TODO や FIXME を見つけたら、必ずチケットを作成します。

**良い例**

```dart
// TODO: 画面遷移をする時にuserIdが渡せてないので渡すように対応必要
void hoge() {
  // ...
}

// TODO: 仕様確認中のため別チケットで対応。=> チケット番号32参照
void foo() {
  // ...
}
```

**悪い例**

```dart
// FIXME:
void hoge() {
  // ...
}

// FIXME: この部分はもっと良くなるべき。
void foo() {
  // ...
}
```

## 自動テストに関するルール

ありとあらゆるコードに対して、テストを書くのは、限られた予算の中では、現実的ではないことが多々あります。

そういった際は、ビジネスロジックは、自動テストを書くことを推奨しています。

ビジネスロジックは、アプリ固有のロジックで、複雑になりやすく、かつアプリの核心となるので、バグが発生すると致命的な問題につながりやすいからです。

テストが書いてあることで、運用保守フェーズでも自信を持って変更することができ、検証にかかるコストを抑えることができます。

<Info>ビジネスロジックは複雑になるので、テストを書こう！</Info>
